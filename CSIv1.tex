\documentclass[10pt]{article}
\usepackage{color}
\definecolor{gray}{rgb}{0.7,0.7,0.7}
\usepackage{framed}
\usepackage{enumitem}
\usepackage{longtable}

\addtolength{\textwidth}{3.4cm}
\addtolength{\hoffset}{-1.7cm}
\addtolength{\textheight}{4cm}
\addtolength{\voffset}{-2cm}

\makeindex

\begin{document}

\title{Coordinate Sorted Index}
\author{The SAM/BAM Format Specification Working Group}
\maketitle

\section{Binary Format Definition}
\begin{table}[ht]
{\small
\begin{tabular}{|l|l|l|l|l|l|r|}
  \cline{1-7}
  \multicolumn{4}{|c|}{\bf Field} & \multicolumn{1}{c|}{\bf Description} & \multicolumn{1}{c|}{\bf Type} & \multicolumn{1}{c|}{\bf Value} \\\cline{1-7}
  \multicolumn{4}{|l|}{\sf magic} & Magic string & {\tt char[4]} & {\tt CSI\char92 1}\\\cline{1-7}
  \multicolumn{4}{|l|}{\sf min\_shift} & \# bits for the minimal interval & {\tt int32\_t} & [14]\\\cline{1-7}
  \multicolumn{4}{|l|}{\sf depth} & Depth of the binning index & {\tt int32\_t} & [5]\\\cline{1-7}
  \multicolumn{4}{|l|}{\sf l\_aux} & Length of auxilary data & {\tt int32\_t} & [0]\\\cline{1-7}
  \multicolumn{4}{|l|}{\sf aux} & Auxilary data & {\tt uint8\_t[l\_aux]} & \\\cline{1-7}
  \multicolumn{4}{|l|}{\sf n\_ref} & \# reference sequences & {\tt int32\_t} & \\\cline{1-7}
  \multicolumn{7}{|c|}{\textcolor{gray}{\it List of indices (n=n\_ref)}} \\\cline{2-7}
  & \multicolumn{3}{l|}{\sf n\_bin} & \# distinct bins & {\tt int32\_t} & \\\cline{2-7}
  & \multicolumn{6}{c|}{\textcolor{gray}{\it List of distinct bins (n=n\_bin)}} \\\cline{3-7}
  & & \multicolumn{2}{l|}{\sf bin} & Distinct bin & {\tt uint32\_t} & \\\cline{3-7}
  & & \multicolumn{2}{l|}{\sf loffset} & (Virtual) file offset of the first overlapping record & {\tt uint64\_t} & \\\cline{3-7}
  & & \multicolumn{2}{l|}{\sf n\_chunk} & \# chunks & {\tt int32\_t} & \\\cline{3-7}
  & & \multicolumn{5}{c|}{\textcolor{gray}{\it List of chunks (n=n\_chunk)}} \\\cline{4-7}
  & & & {\sf chunk\_beg} & (Virtual) file offset of the start of the chunk & {\tt uint64\_t} & \\\cline{4-7}
  & & & {\sf chunk\_end} & (Virtual) file offset of the end of the chunk & {\tt uint64\_t} & \\\cline{1-7}
  & \multicolumn{6}{c|}{\textcolor{gray}{\it Optional dummy entry for stats (included in n\_bin)}} \\\cline{3-7}
  & & \multicolumn{2}{l|}{\sf bin} & Dummy bin number & {\tt uint32\_t} & See below \\\cline{3-7}
  & & \multicolumn{2}{l|}{\sf n\_chunk} & \# chunks & {\tt int32\_t} & 2 \\\cline{3-7}
  & & \multicolumn{5}{c|}{\textcolor{gray}{\it First chunk for dummy bin}} \\\cline{4-7}
  & & & {\sf unmapped\_beg} & (Virtual) file offset of the start of unmapped but placed & {\tt uint64\_t} & \\\cline{4-7}
  & & & {\sf unmapped\_end} & (Virtual) file offset of the end of unmapped but placed & {\tt uint64\_t} & \\\cline{4-7}
  & & \multicolumn{5}{c|}{\textcolor{gray}{\it Second chunk for dummy bin}} \\\cline{4-7}
  & & & {\sf mapped\_count} & Number of mapped read-segments for this reference & {\tt uint64\_t} & \\\cline{4-7}
  & & & {\sf unmapped\_count} & Number of unmapped read-segments for this reference & {\tt uint64\_t} & \\\cline{1-7}
  \multicolumn{4}{|l|}{\sf n\_no\_coor} & (Optional) \# unmapped unplaced reads ({\sf RNAME} *) & {\tt uint64\_t} & \\
  \cline{1-7}
\end{tabular}}
\end{table}

\section{Dummy Bin}
The number of the dummy bin varies according to the depth of the binning index and can be
calculated by:

\begin{verbatim}
dummy_bin = ((1<<(3 * depth + 3)) - 1) / 7 + 1
\end{verbatim}

The dummy bin allows tools that are capable of reading it to provide a summary of the number of
mapped and unmapped read-segments per reference, and any unmapped unplaced read-segments
(see the SAM/BAM specification recommended practices for details on why unmapped reads can 
have a position). This is done by using additional fields recorded in the BAI file by the indexing tool 
in a bin 1 above the normal maximum bin number. These optional fields are two entries 
({\sf n\_chunk} $= 2$) for each reference indexed under the entry for dummy {\sf bin}, and the 
trailing {\sf n\_no\_coor} field at the end of the file.

\section{Virtual Offsets}
BGZF files support random access through the CSI file index.
To achieve this, the CSI file index uses virtual file offsets into the
BGZF file. Each virtual file offset is an unsigned 64-bit integer, defined
as: coffset<<16|uoffset, where coffset is an unsigned byte offset into
the BGZF file to the beginning of a BGZF block, and uoffset is an
unsigned byte offset into the uncompressed data stream represented
by that BGZF block. Virtual file offsets can be compared, but
subtraction between virtual file offsets and addition between a virtual
offset and an integer are both disallowed.

\section{Calculation of Bin Number}

{\footnotesize
\begin{verbatim}
/* calculate bin given an alignment covering [beg,end) (zero-based, half-closed-half-open) */
int reg2bin(int64_t beg, int64_t end, int min_shift, int depth)
{
    int l, s = min_shift, t = ((1<<depth*3) - 1) / 7;
    for (--end, l = depth; l > 0; --l, s += 3, t -= 1<<l*3)
        if (beg>>s == end>>s) return t + (beg>>s);
    return 0;
}
/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */
int reg2bins(int64_t beg, int64_t end, int min_shift, int depth, int *bins)
{
    int l, t, n, s = min_shift + depth*3;
    for (--end, l = n = t = 0; l <= depth; s -= 3, t += 1<<l*3, ++l) {
        int b = t + (beg>>s), e = t + (end>>s), i;
        for (i = b; i <= e; ++i) bins[n++] = i;
    }
    return n;
}
\end{verbatim}
}

\end{document}
